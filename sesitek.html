<!DOCTYPE html>
<html>
  <head>
    <title>sešítek</title>

    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

    <style>
    </style>

    <script src="js/libs/jquery-1.10.2.js"></script>
    <script src="js/libs/underscore-1.5.1.js"></script>
    <script src="js/libs/ace/src-noconflict/ace.js" type="text/javascript" charset="utf-8"></script>

    <script src="js/libs/jquery.splitter-0.8.0.js"></script>
    <link href="css/libs/jquery.splitter.css" rel="stylesheet">



    <script src="js/utils.js"></script>
    <!--<script src="js/fishtronDB.js"></script>-->
    <script src="js/sesitek.js"></script>
    <script src="js/zone2d.js"></script>

    
<script>
$(function(){ 
  renderAll();
});
</script>

</head>
<body>

<h1>sešítek</h1>

<section id="obsah">Obsah</section>
<div id="contents"></div>

<section id="todo-index">TODO index</section>
<div id="todoIndex"></div>

<!-- 

db   dD d88888b  .o88b. db    db 
88 ,8P' 88'     d8P  Y8 `8b  d8' 
88,8P   88ooooo 8P       `8bd8'  
88`8b   88~~~~~ 8b         88    
88 `88. 88.     Y8b  d8    88    
YP   YD Y88888P  `Y88P'    YP    

-->

<section id="kecy">Kecy</section>

Pokus jestli je praktické psát si poznámky v html/js a zda
se to osvědčí jako kontrapart autoepištoly.

Zatím tu diskutuju pár věcí co se mi honěj hlavou poslední dobou,
postupně bych to chtěl obohacovat o obecnější témata - pokud se to osvědčí
jako dobrá metoda. Teď navíc zkouším přidat sekci o Fishtronu zaměřenou na další postup.

<!--
 
d8888b. db    db d8888b.  .d88b.  db    db db    db 
88  `8D 88    88 88  `8D .8P  Y8. 88    88 `8b  d8' 
88oooY' 88    88 88   88 88    88 Y8    8P  `8bd8'  
88~~~b. 88    88 88   88 88    88 `8b  d8'    88    
88   8D 88b  d88 88  .8D `8b  d8'  `8bd8'     88    
Y8888P' ~Y8888P' Y8888D'  `Y88P'     YP       YP    
                                                   
-->

<section id="slechteni-budov">Šlechtění budov</section>


<canvas id="budovy_canvas" width="512" height="512" style="border: 1px dotted AliceBlue"></canvas>

<script>
$(function(){

    //var 
    house = mkHouse({
      x: 100,
      y: 100,
      w: 168,
      h: 100,
      drawJoints: true,
      jointRadius: 3,
      outPos: {x:184, y:250}
    });

    var ctx = $('#budovy_canvas')[0].getContext('2d'); 
    house.draw({ctx:ctx, w:512, h:512});   
    
    
    setTimeout(function(){
      house.vSplit('in',0.5);
      house.draw();      
    },500);

});
</script>



<script show="false">

function mkGraph () {
  var self;

  var vs = {};
  var es = {};

  function addV (vid, data) {
    assert(vs[vid] === undefined, 'mkGraph.addV : vid must be unique.');

    vs[vid] = {
      vid:  vid,
      eids: [],
      es:   [],
      data: data
    };

    return self;
  } 

  function addE (eid, uid, vid, data) {
    assert(es[eid] === undefined, 'mkGraph.addE : eid must be unique.');    

    if (!vs[uid]) { addV(uid, {}); }
    if (!vs[vid]) { addV(vid, {}); }

    var u = vs[uid];
    var v = vs[vid];

    var e = {
      eid:  eid,
      uid:  uid,
      vid:  vid,
      u:    u,
      v:    v,
      data: data
    };   

    es[eid] = e; 

    vs[uid].eids.push(eid);
    vs[vid].eids.push(eid);
    vs[uid].es.push(e);
    vs[vid].es.push(e);

    return self;
  }

  function eachE (fun) {
    _.each(_.values(es), fun);
  }

  function eachV (fun) {
    _.each(_.values(vs), fun);
  }

  self = {
    vs: vs,
    es: es,
    addV: addV,
    addE: addE,
    eachE: eachE,
    eachV: eachV,
  };

  return self;
}

function drawEllipse (ctx, color, centerX, centerY, width, height) {
  var startingAngle = 0;
  var endingAngle = 2 * Math.PI; 

  var circumference = Math.max(width, height);
  var scaleX = width / circumference;
  var scaleY = height / circumference;

  ctx.fillStyle = color;
  ctx.save();
  ctx.translate(centerX, centerY);
  ctx.scale(scaleX, scaleY);
  ctx.beginPath();
  ctx.arc(0, 0, circumference/2, startingAngle, endingAngle);
  ctx.fill();
  ctx.restore();  
}

function mkHouse (opts) {
  opts = _.extend({
    w: 100,
    h: 100,
    x: 10,
    y: 10,
    drawJoints: true,
    jointRadius: 5,
    outPos: {x:10, y:10},
  },opts);

  var self;
  var rooms, walls;

  function eachRoomWall (room, fun) {
    _.each( room.es, function (roomEdge) {
      _.each( roomEdge.data.zigZag, fun);
    });      
  }

  function eachRoomJoint (room, fun) {
    eachRoomWall(room, function (wall) {
      fun(wall.u); 
    });     
  }

  function getRoomInterval (room, axis) {
    var min =   Number.MAX_VALUE; 
    var max = - Number.MAX_VALUE;

    eachRoomJoint(room, function (joint) {
      var x = joint.data[axis];
      if (x<min) {min = x;}
      if (x>max) {max = x;}
    });    

    return [min, max];
  }

  function getRoomCenter (room) {
    if (room.vid === 'out') {
      return opts.outPos;
    }

    var mmx = getRoomInterval(room, 'x');
    var mmy = getRoomInterval(room, 'y');
    return {
      x: (mmx[1]+mmx[0])/2, 
      y: (mmy[1]+mmy[0])/2 
    };
  }


  function vSplit (roomID, where) {
    assert(where > 0, 'mkHouse.vSplit : "where" must be > 0');
    assert(where < 1, 'mkHouse.vSplit : "where" must be < 1');

    var room = rooms.vs[roomID];

    assert(room !== undefined, 'mkHouse.vSplit : invalid roomID "'+roomID+'"');

    var roomInterval = getRoomInterval(room, 'x');
    var min = roomInterval[0];
    var max = roomInterval[1];
    var whereX = min + (max - min) * where;

    log('whereX:', whereX);

    eachRoomWall(room, function (wall) {
      var uX = wall.u.data.x;
      var vX = wall.v.data.x;
      if ( (uX<whereX && whereX<vX) ||
           (vX<whereX && whereX<uX) ) {
        log(wall.eid);
      }
    });


  }

  function init () {
    var x = opts.x;
    var y = opts.y;
    var w = opts.w;
    var h = opts.h;

    walls = mkGraph()
      .addV('v1', {x: x,   y: y   })
      .addV('v2', {x: x+w, y: y   })
      .addV('v3', {x: x+w, y: y+h })
      .addV('v4', {x: x,   y: y+h })
      .addE('e1', 'v1', 'v2', {})
      .addE('e2', 'v2', 'v3', {})
      .addE('e3', 'v3', 'v4', {})
      .addE('e4', 'v4', 'v1', {})
    ;

    var zigZag0 = [ 
      walls.es['e1'],
      walls.es['e2'],
      walls.es['e3'],
      walls.es['e4'] 
    ];

    rooms = mkGraph()
      .addV('in',  {})
      .addV('out', {})
      .addE('e0', 'in', 'out', {zigZag: zigZag0} )
    ;

  }

  function drawWalls (ctx) {
    ctx.strokeStyle = 'black';
    ctx.beginPath();  
    walls.eachE(function (e) {
      ctx.moveTo(e.u.data.x, e.u.data.y);
      ctx.lineTo(e.v.data.x, e.v.data.y);
    });
    ctx.stroke();

    if (opts.drawJoints) {
      ctx.fillStyle = 'black';
      walls.eachV(function (v) {
        ctx.beginPath();
        ctx.arc(v.data.x,v.data.y,opts.jointRadius,0,Math.PI*2);
        ctx.fill();
      });
    }
  }

  function drawRooms (ctx) {
    ctx.strokeStyle = 'red';
    ctx.beginPath();
    rooms.eachE(function (e) {
      var cu = getRoomCenter(e.u);
      var cv = getRoomCenter(e.v);
      ctx.moveTo(cu.x, cu.y);
      ctx.lineTo(cv.x, cv.y);
    });
    ctx.stroke();
    rooms.eachV(function (room) {
      var c = getRoomCenter(room);
      var w = ctx.measureText(room.vid).width;
      drawEllipse(ctx, 'red' , c.x, c.y, w+10, 20);
      ctx.fillStyle = 'white';
      ctx.fillText(room.vid, c.x-w/2-1, c.y+3);
    });
  }

  var drawOpts = null;

  function draw (drawOpts_) {

    if   (drawOpts_ !== undefined) {drawOpts = drawOpts_;} 
    else {assert(drawOpts !== null, 'ERR: mkHouse.draw - no drawOpts supplied');}

    var ctx = drawOpts.ctx;

    ctx.fillStyle = 'white';
    ctx.fillRect(0, 0, drawOpts.w, drawOpts.h); 

    drawWalls(ctx);
    drawRooms(ctx);
  }

  init();

  self = {
    rooms: rooms,
    walls: walls,
    draw:  draw,
    vSplit: vSplit,
  };
  
  return self;
}

</script>

<!--

d88888D  .d88b.  d8b   db d88888b .d888b. d8888b. 
YP  d8' .8P  Y8. 888o  88 88'     VP  `8D 88  `8D 
   d8'  88    88 88V8o 88 88ooooo    odD' 88   88 
  d8'   88    88 88 V8o88 88~~~~~  .88'   88   88 
 d8' db `8b  d8' 88  V888 88.     j88.    88  .8D 
d88888P  `Y88P'  VP   V8P Y88888P 888888D Y8888D' 

-->

<section id="zone2d">Zone2D</section>

<canvas id="zone2d_canvas" width="512" height="512"></canvas>

<script>$(function(){

  


  var img = new Image();
  img.onload = function () {
  
    function drawFrame (ctx, frame, x,y) {
      var w = frame.w, h = frame.h;
      var dx = frame.dx || 0, dy = frame.dy || 0;    
      ctx.drawImage(img, frame.x, frame.y, w, h, 
                         x+dx,    y+dy,    w, h);
    }


    var SANTA_FE = 
    [ ".FFF............................"
     , "...F............................"
     , "...F.....................FFF...." 
     , "...F....................F....F.." 
     , "...F....................F....F.." 
     , "...FFFF.FFFFF........FF........." 
     , "............F................F.." 
     , "............F.......F..........." 
     , "............F.......F..........." 
     , "............F.......F........F.." 
     , "....................F..........." 
     , "............F..................." 
     , "............F................F.." 
     , "............F.......F..........." 
     , "............F.......F.....FFF..." 
     , ".................F.....F........" 
     , "................................" 
     , "............F..................."             
     , "............F...F.......F......."
     , "............F...F..........F...." 
     , "............F...F..............."             
     , "............F...F..............."
     , "............F.............F....." 
     , "............F..........F........" 
     , "...FF..FFFFF....F..............." 
     , ".F..............F..............." 
     , ".F..............F..............." 
     , ".F......FFFFFFF................." 
     , ".F.....F........................" 
     , ".......F........................" 
     , "..FFFF.........................." 
     , "................................" ];

    function mkSimpleObj (frame) {
      return {
        draw: function (ctx, x, y) {
          drawFrame(ctx, frame, x, y);
        }
      };
    }



    var ant = (function(){
      var frames = {
        u: {x:160,y:78,w:16,h:16},
        d: {x:176,y:80,w:16,h:16},
        r: {x:200,y:78,w:16,h:16},
        l: {x:219,y:78,w:18,h:16},
      }
      return {
        dir: 'r',
        eaten: 0,
        isFoodAhead: function () {
          var ahPos = this.aheadPos();
          return this.board[ahPos.i][ahPos.j].length > 0;
        },
        aheadPos: function () {
          var i = this.pos.i;
          var j = this.pos.j;
          switch( this.dir ){
            case 'r' : j = (j+1+32) % 32 ; break;
            case 'l' : j = (j-1+32) % 32 ; break;
            case 'u' : i = (i-1+32) % 32 ; break;
            case 'd' : i = (i+1+32) % 32 ; break;
          }
          return {i:i,j:j};
        },
        move: function () {
          var i_old = this.pos.i, j_old = this.pos.j;
          var newPos = this.aheadPos();
          var i = newPos.i, j = newPos.j;

          var field_old = this.board[i_old][j_old];
          var index_old = field_old.indexOf(this);
          field_old.splice(index_old, 1);

          this.eaten += this.board[i][j].length;

          this.board[i][j] = [this];
          this.pos = {i:i, j:j};
        },
        left: function () {
          switch( this.dir ){
            case 'r' : this.dir = 'u'; return; 
            case 'l' : this.dir = 'd'; return; 
            case 'u' : this.dir = 'l'; return; 
            case 'd' : this.dir = 'r'; return; 
          }
        },
        right: function () {
          switch( this.dir ){
            case 'r' : this.dir = 'd' ; return;
            case 'l' : this.dir = 'u' ; return;
            case 'u' : this.dir = 'r' ; return;
            case 'd' : this.dir = 'l' ; return;
          } 
        },
        draw: function (ctx, x, y) {
          drawFrame(ctx, frames[this.dir], x, y);
        }
      }
    })();

    

    var seed = mkSimpleObj({x:212,y:98,w:25,h:22});
    

    //var 
    testZona = Zone2D.mk({
      side: 32,
      fieldSide: 16,
      initBoard: function (board) {
        ant.board = board;
        ant.pos = {i:0,j:0};
        board[ant.pos.i][ant.pos.j].push(ant);
      },
      initField: function (arr, pos) {
        if (SANTA_FE[pos.i][pos.j] === 'F') {
          arr.push(seed);
        }
      }
    });

    _.extend(testZona, {
      ant:         ant,
      left:        function(){ ant.left();  this.draw(); },
      right:       function(){ ant.right(); this.draw(); },
      move:        function(){ ant.move();  this.draw(); },
      isFoodAhead: function(){ return ant.isFoodAhead(); } 
    });


    var ctx = $('#zone2d_canvas')[0].getContext('2d'); 
    
    testZona.draw(ctx);   
  
  };
  img.src = 'img/hra/img.png';

    
});</script>

<!--

.88b  d88. d8888b.  .d8b.  db    db d88888b d8b   db  .o88b. d888888b 
88'YbdP`88 88  `8D d8' `8b 88    88 88'     888o  88 d8P  Y8   `88'   
88  88  88 88oobY' 88ooo88 Y8    8P 88ooooo 88V8o 88 8P         88    
88  88  88 88`8b   88~~~88 `8b  d8' 88~~~~~ 88 V8o88 8b         88    
88  88  88 88 `88. 88   88  `8bd8'  88.     88  V888 Y8b  d8   .88.   
YP  YP  YP 88   YD YP   YP    YP    Y88888P VP   V8P  `Y88P' Y888888P

-->

<section id="mravenci">Mravenci pokusy</section>


<canvas id="ant_canvas" width="512" height="512"></canvas>

<div>
  <input type="button" id="ant_canvas_play" value="play">
  kroků na vykreslení:
  <input id="ant_canvas_steps_per_draw" value="5" style="width:30px">
  Proběhlo <span id="ant_canvas_steps">0</span> kroků.
</div>

<script>
$(function () {
  var fps = 1000;

  var ctx = $('#ant_canvas')[0].getContext('2d'); 
  var zona = mkZone_(poleInit);
  drawZone2D_(ctx, zona);
  
  var play = false;

  var numStepsEl = $('#ant_canvas_steps');
  var numSteps = 0;
  var stepsPerDrawInput = $('#ant_canvas_steps_per_draw');
  var stepsPerDraw = stepsPerDrawInput.val();

  var step = function () {
    if (play) {
      drawZone2D_(ctx, zona);  

      for(var i=0; i<stepsPerDraw; i++){
        stepZone_(zona);
        numSteps++;
      }
      
      numStepsEl.html(numSteps);
      setTimeout(step,1000/fps);
    }
  }

  var button = $('#ant_canvas_play');  
  button.click(function(){
    play = !play;

    if (play) {
      button.val('pause');
      step();  
    } else {
      button.val('play');
    }
    
  });

  stepsPerDrawInput.change(function(){
    var newVal = parseInt(stepsPerDrawInput.val());
    if (isNaN(newVal)) {
      stepsPerDrawInput.val(stepsPerDraw);
      newVal = stepsPerDraw;
    }
    stepsPerDraw = newVal;
    log(stepsPerDraw);
  });


  
});
</script>






<p>Výsledek po cca 70 000 krocích (dáno 9x vedle
  sebe aby vynikly důsledky toroidnosti).
  (5%, 25%, 25%, 45%)</p>

<img src="img/sesitek/tridici_mravenci.png" style="width: 512px">

<p>Pokus 2, 310 000 kroků:</p>

<img src="img/sesitek/tridici_mravenci_2.png" style="width: 512px">

<p>Pokus 3, 40 000 kroků:</p>

<img src="img/sesitek/tridici_mravenci_3.png" style="width: 512px">

<p>Pokus 4, 60 000 kroků:</p>

<img src="img/sesitek/tridici_mravenci_4.png" style="width: 512px">

<p>Pokus 5, 20 000 (5, 45, 45, 0): </p>

<img src="img/sesitek/tridici_mravenci_5.png" style="width: 512px">

<p>Pokus 6, 730 000 (5%, 47.5%, 47.5%, 0%): </p>

<img src="img/sesitek/tridici_mravenci_6.png" style="width: 512px">


<script>

function drawZone2D_ (ctx, zone) {
  var side = 16;
  var i = 0;
  z_each(zone,function(pole,pos){
    var x = pos[0];
    var y = pos[1];
    
    var color = [119, 140, 79];
    for (var oi in pole.inside) {
      var obj = pole.inside[oi];
      if( obj.color ){
        color = obj.color;
        if( obj.typ === 'ant' ){
          break;
        }
      }
    }

    ctx.fillStyle = 'rgb(' + color.join() + ')';
    ctx.fillRect(x*side, y*side, (x+1)*side, (y+1)*side);
  
    i++;
  });
  //log(i);
}

function stepZone_ (zone) {

  z_each(zone,function(pole,pos){
    for (var oi in pole.inside) {
      var obj = pole.inside[oi];

      if (!obj.hasStepped) {

        if (obj.mem) {
          updateMem(obj.mem, pole);
        }

        if (obj.step && !obj.hasStepped) { 
          var stepRes = obj.step( obj.mkInfo(obj,pole) ); 
          if (stepRes.action) {
            doAction(stepRes.action,obj,pole);
          }
          if (stepRes.move) {
            moveObj(stepRes.move, zone, pole, obj, pos);
          }
        }

        obj.hasStepped = true;
      }
    }
  });

  z_each(zone,function(pole,pos){
    for (var oi in pole.inside) {
      var obj = pole.inside[oi];
      obj.hasStepped = false;
    }
  });

}

function updateMem (mem, pole) {
  mem.shift();
  
  var memCell = null;
  for (var oi in pole.inside) {
    var obj = pole.inside[oi];
    if (obj.typ == 'W' || obj.typ == 'B') {
      memCell = obj.typ;
    }
  }

  mem.push(memCell);

  //log(mem);
}

function moveObj (move, zone, pole, obj, pos) {
  //log('move ' + move);
  
  var poleTam;
  var dx = 0;
  var dy = 0;

  switch (move) {
    case 'U'    : dy = -1;     break;
    case 'D'    : dy =  1;     break;
    case 'L'    : dx = -1;     break;
    case 'R'    : dx =  1;     break;
  }

  if (dx || dy) {
    
    var x = ((ZONE_SIDE+pos[0]+dx) % ZONE_SIDE);
    var y = ((ZONE_SIDE+pos[1]+dy) % ZONE_SIDE);
    
    var poleTam = poleAt(zone, [x,y] );
    if (poleTam && poleTam.inside){
      poleTam.inside.push(obj);
      delObj(pole,obj);
    }
  }
}

function doAction (action,ant,pole) {
  
  switch (action) {
    case 'PICK' : pickObj(ant, pole); break;
    case 'PUT'  : putObj (ant, pole); break;
  }  

}

function pickObj (ant, pole) {
  if (ant.inside.length === 0) {
    for (var oi in pole.inside) {
      var obj = pole.inside[oi];
      if( obj.typ === 'W' || obj.typ === 'B' ) {
        ant.inside.push(obj);
        delObj(pole,obj);
        break;
      }
    }
  }
}

function putObj (ant, pole) {
  if (ant.inside.length > 0){
    var obj = ant.inside.pop();
    pole.inside.push(obj);
  }
}

function delObj (pole,obj) {
  var del_oi = undefined;
  var inside = pole.inside;
  for (var oi in inside) {
    if (inside[oi].id === obj.id) {
      del_oi = oi;
      break;
    }
  }

  if( del_oi !== undefined ){
    pole.inside.splice(del_oi,1);
  }
}



function mkZone_ (initFun, dim, pos) {
  if (dim === undefined) {dim = NUM_DIM; }
  if (pos === undefined) {pos = []; }
  if (initFun === undefined) {initFun = defaultZoneInit2D;}
  if (dim === 0) {return initFun(pos); }
  
  var zone = []; 
  for (var i = 0; i < ZONE_SIDE; i++) {

    var subZone = mkZone_(initFun, dim-1, pos.concat([i]));
    zone.push(subZone);

  }
  return zone;
}


var g_id = 0;


function mkAnt () {

  var ANT_MEM_SIZE = 10;
  var K1 = 0.1;
  var K2 = 0.1;

  var mkInfo = function (ant,pole) {

    var frekv = function (typ) {
      var num = 0;
      for (var i = 0; i < ant.mem.length; i++) {
        if( ant.mem[i] === typ ){
          num++;
        }
      }
      return num / ant.mem.length;
    };

    var getTypNazemi = function () {
      for (var oi in pole.inside) {
        var obj = pole.inside[oi];
        if( obj.typ === 'W' || obj.typ === 'B' ) {
          return obj.typ;
        }
      }
      return null;
    };

    var getTypNese = function () {
      for (var oi in ant.inside) {
        var obj = ant.inside[oi];
        if( obj.typ === 'W' || obj.typ === 'B' ) {
          return obj.typ;
        }
      }
      return null;
    };

    var canPut = function () {
      var isFree = ant.inside.length === 0;
      
      var poleHasNoBorW = true;
      for (var oi in pole.inside) {
        var obj = pole.inside[oi];
        if( obj.typ === 'W' || obj.typ === 'B' ) {
          poleHasNoBorW = false;
          break;
        }
      }

      return !isFree && poleHasNoBorW;
    };

    var canPick = function () {
      var isFree = ant.inside.length === 0;
      
      var reachesOnBorW = false;
      for (var oi in pole.inside) {
        var obj = pole.inside[oi];
        if( obj.typ === 'W' || obj.typ === 'B' ) {
          reachesOnBorW = true;
          break;
        }
      }

      return isFree && reachesOnBorW;
    };

    return {
      canPick: canPick,
      canPut: canPut,
      frekv: frekv,
      getTypNazemi: getTypNazemi,
      getTypNese: getTypNese
    };
  };

  var step = function (antInfo) {

    var typNazemi = antInfo.getTypNazemi();
    var typNese   = antInfo.getTypNese();

    /*
    log( 'f_W    : ' + antInfo.frekv('W') );
    log( 'f_B    : ' + antInfo.frekv('B') );
    log( 'Nazemi : ' + typNazemi );
    log( 'Nese   : ' + typNese );
    */

    var move;
    var action = undefined;
    
    var ball1 = Math.random();

    if (typNazemi === null && typNese !== null) {
      var fr    = antInfo.frekv(typNese);
      var p_put = fr / (K2+fr);
      p_put = p_put * p_put;
      if(ball1 < p_put){
        action = 'PUT';
      }
    }

    if (typNazemi !== null && typNese === null) {
      var fre    = antInfo.frekv(typNazemi);
      var p_pick = K1 / (K1+fre);
      p_pick = p_pick * p_pick;
      if(ball1 < p_pick){
        action = 'PICK';
      } 
    }

    /* if (antInfo.canPick()) { 
      action = 'PICK';
    } else if (antInfo.canPut()) {
      action = 'PUT';  
    } */

    var ball = Math.random();

    if      (ball < 1/4) {move = 'L'; }
    else if (ball < 2/4) {move = 'R'; }
    else if (ball < 3/4) {move = 'U'; }
    else if (ball < 4/4) {move = 'D'; }  

    return {
      move: move,
      action: action
    };
  };

  var id = g_id;
  g_id ++;

  var mem = [];

  for (var i = 0; i < ANT_MEM_SIZE; i++){
    mem.push(null);
  }

  return {
    id: id,
    typ: 'ant', 
    mem: mem,
    color: [119,49,65],
    inside: [],
    step: step,
    mkInfo: mkInfo
  };
}

//oneAntHax = true;

var POLE_DIST = mkDist([
    ['ant', 5],
    ['B'  , 47.5],
    ['W'  , 47.5],
    ['nic', 0 ]]);

function poleInit (pos) {
  var inside = [];
  
  switch (POLE_DIST.get()) {
    case 'ant': inside.push(mkAnt()); break;
    case 'B'  : inside.push({typ:'B',color:[0,0,0]}); break;
    case 'W'  : inside.push({typ:'W',color:[255,255,255]}); break;
    case 'nic': break;
  }

  return { 
    inside: inside 
  };
};

</script>






<!--

d88888b d888888b .d8888. db   db d888888b d8888b.  .d88b.  d8b   db 
88'       `88'   88'  YP 88   88 `~~88~~' 88  `8D .8P  Y8. 888o  88 
88ooo      88    `8bo.   88ooo88    88    88oobY' 88    88 88V8o 88 
88~~~      88      `Y8b. 88~~~88    88    88`8b   88    88 88 V8o88 
88        .88.   db   8D 88   88    88    88 `88. `8b  d8' 88  V888 
YP      Y888888P `8888Y' YP   YP    YP    88   YD  `Y88P'  VP   V8P

-->


<section id="fishtron">Fishtron</section>

<h3>GAUK kecy</h3>

<h4>Současný stav poznání</h4>

<p>
Genetické programování (GP) je technika umělé inteligence spadající do
širší kategorie evolučních algoritmů - metaheuristických optimalizačních algoritmů
inspirovaných přirozeným výběrem probíhajícím v přírodě. 
GP se pro zadaný problém snaží nalézt počítačový program (přesněji jeho syntaktický strom) 
schopný tento problém vyřešit. Tato technika byla navržena Johnem Kozou [KOZA1].
Ukazuje se, že se jedná o velmi úspěšnou techniku v řadě oblastí,
její úspěšnost se navíc dále podstatně zvyšuje s přibývající výpočetní silou 
kterou lze navíc dobře paralelizovat [KOZA4].
GP pracuje s populací jedinců (programů řešících daný problém), na začátku vygenerovanou pomocí generujícího algoritmu.
Každá další generace je z předchozí vytvořena na základě selekce (založené na kvalitě řešení) a genetických operátorů (nejčastěji křížení a mutace).
Další sympatickou vlastností GP je jeho snadná hybridizace s jinými optimalizačními 
algoritmy; ty lze chápat jako konkrétní algoritmus generování, případně jako genetické operátry.
Na druhou stranu je standardní GP jednoduše popsatelný algoritmus, což je výhoda pro 
jeho další zobecňování.
GP sestavuje jedince (program) z dvou množin stavebních symbolu;
z množiny funkčních symbolů F a množiny terminálů T. Ve standardním GP je vyžadována
tzv. closure podmínka nad těmito množinami, tzn. že všechny funkce z F musí přijímat
všechny prvky T jako své argumenty a vracet jen výstupní hodnoty akceptovatelné jako
argumenty všemi funkcemi z F. Toto můžeme shrnout tvrzením, že všechny stavební symboly
musejí být nad jediným typem. Pokud toto omezení odstraníme, dostáváme genetické programování 
nad typovaným jazykem.
</p>
<p>
Tímto rozšířením GP se zabívalo již několik prací [CITACE].
Z jiného úhlu pohledu můžeme zavedení typů do GP naopak chápat jako zavedení omezení na jednotlivé
stavební symboly, tedy na způsob jakým mohou být tyto symboly navzájem skládány.  
Typy tak efektivně zmenšují prohledávaný prostor programů, množina stavebních symbolů tak 
může být podstatně větší a rozmanitější.
Odstranění closure podmínky umožňuje použití přirozenějších funkcí a terminálů používaných
v člověkem psaných programech na rozdíl od netypovaného GP, kde je tato množina 
pečlivě navržena přesně na míru danému programu. Jak ukazuje praxe z funkcionálních jazyků, 
konstrukcí polymorfních higher-order funkcí můžeme pohodlně tvořit konstrukty odpovídající 
prvkům, které jsou standardně pevnou součástí jazyka (podmínky, cykly, atd.) ale 
i obecnější matematické konstrukty uchopující pojem výpočtu jako jsou monady či arrows 
[Hug00?? nevim esli citovat - to je obecny o šipkacha monadach].
</p>
<p>
Pro reprezentaci typovaného programovacího jazyka může být použit lambda kalkulus,
který se standardně využívá při studiu typových systémů. 
Můžeme ho navíc považovat za zobecnění S-výrazů (přidáním anonymních funkcí) 
používaných ve standardním GP. Je to jazyk velice kompaktní a pro porgramování přirozený, 
v zásadě má tři konstrukty (proměnná/konstanta, aplikace funkce, anonymní funkce), 
přes svou jednoduchost je lambda kalkul ve své netypované verzi turingovsky kompletní.
Naproti tomu např. programy v symply typed lambda kalkulu mají garantováno, že vždy zastaví. 
Díky Curry-Howardově korespondeci se navíc lambda kalkulus používá jako prostředek pro 
formální uchopení pojmu důkazu (typ odpovídá logickému tvrzení, lambda term důkazu tohoto tvrzení),
z čehož je patrné, že problém generování lambda termů daného typu a automatické dokazování logických
tvrzení jsou velmi příbuzné problémy.
Lambda kalkulus a s ním spojené typové systémy jsou podrobně sudovány v [POSLEDNí-BARENDRECHT],
kde je mimojiné diskutována metoda pro generování lambda termů (v normální formě) pro daný typ.
</p>



<h4>Cíle řešení projektu</h4>

<p>
Cílem projektu je navrhnout systém efektivního začlenění typů do GP spolu s
vhodnými genetickými operátory a programy generujícími algoritmy. 
Dále pak podrobněji prozkoumat důsledky, které takový systém má na možnosti volby
množiny stavebních symbolů pro různé problémy.
</p>

<p>
Nalezení typového systému vhodné síly není triviální problém. 
Pro lepší ilustraci tohoto problému je užitečné představit si spektrum 
systémů řešících problémy v závyslosti na síle typového systému, 
nad kterým takový systém pracuje. 
Na jednom konci takového spektra leží standardní netypované GP; 
zde je vygenerování jedince triviální operací a práce takového systému
tkví v kombinování těchto nedokonalých řešení do čím dál lepších pomocí
selekce a genetických operátorů. Takový přístup můžeme označit za induktivní;
začíná s konkrétními "pozorováními" (množina náhodných jedinců a jejich kvalita)
a pokračuje k širším zobecněním (výsledný (sub)optimální jedinec).
Na druhém konci spektra leží metody automatického dokazování vět (a s ním
příbuzné metody jako je formální verifikace atd.); zde naproti tomu jde
o vygenerování libovolného důkazu (jedince) vstupního tvrzení (požadovaného typu)
a o další kombinování několika takových důkazů za účelem zdokonalení
nám typicky nejde. Takový přístup můžeme označit za deduktivní;
začíná z teorie (množina stavebních symbolů s přiřazenými typy) a
zadaného tvrzení k dokázaní (typ jedince) a snažíme se dostat k 
libovolnému důkazu tohoto tvrzení (program daného typu).
Typované genetické programování můžeme chápat jako systém někde uprostřed
tohoto spektra, vyvažující a využívající oba přístupy - induktivní i deduktivní.
Volba typového systému proto musí být rozvážná, pokud bychom totiž zvolili příliš
silný typový systém, bude problém nalézt vůbec jediného jedince, natož celou
různorodou populaci.
S mocnějším typovým systémem také přichází možnost zakódovat do něj netriviální
vlastnosti, které chceme aby vygenerovaný jedinec splňoval. Evoluce pak
tyto jedince splňující dané vlastnosti dále zdokonaluje. Při volbě 
genetických operátorů, které zachovávají správné otypování, je zajištěno, že evoluce
tyto požadované vlastnosti neporuší. Splňování určitých vyžadovaných vlastností jedince
je v oblasti evolučních algoritmů často se vyskytující téma, typové systémy 
umožnují toto téma uchupit systematickým a formálně vyzrálým způsobem kompatibilním
s formálními metodami matematické logiky.  
</p>

<p>
V každém evolučním algoritmu je důležitou fází návrh genetických operátorů,
v typovaném GP nad lambda kalkulem je to otevřený problém.
V tomto ohledu budeme klást hlavní důraz na algoritmus generování jedinců,
kterýžto lze přímočaře využít při standardní podobě operátoru mutace.
Dále bude při návrhu genetických operací prozkoumána aplikovatelnost 
teoretických konstruktů z oblasti lambda kalkulu 
(různé redukce, eliminace abstrakcí, atd.).
Budou zkoumany formy "chytrých" genetických operátorů využívající znalost daného problému,
díky tomu bude umožněna spolupráce s dalšími optimalizačními metodami jakou je například
Ant colony optimisation (ACO). 
</p>

<p>
</p>


<pre>
ZBYLé POZNAMKY:
---------------


typy odstranej nutnost problemove zavysle definice "stavebnich bloku"
- ve std gp je tuf specificky "vykrafteny" na miru danymu problemu,
-  typovany gp umoznuje pouzit stejnou sadu pro vice problemu. tim ze Typy pak efektivne redukujou 
velikost prohl prostoru je realny pouzit i velky sady ktery by jinak nebylo mozno v std gp pouzit. 
- zlaty gral by pak bylo mit jednu sadu univerzalni pro vsechny problemy . Pak by se redukovalo jeste vic [
ten termin co pouziva koza ve 4ce pro to co se musi vykraftit clovekem aby... jakoby human supplied 
knowledge] 



meta - zkusit sloučit s implementací
- opt metody maj mnoho prichuti ale uvnitr se opakuji ta sama temata, ty de podchytit zas nakou "knihovnou 
fci" a tyto metody pak muzem slechtit jako by se nechumelilo
- zacnem od jednoduchosti jako nastaveni gp algoritmu jehoz soucasti je ale i strat kera je program a tu 
teda muzem slechtit. Nakonec se muzem dostat az ke slechteni samotnejch opt metod
- otazkou je jak efektivne slechtit tydle meta veci, nsbizi se napr oddeleny subpipulace bezici rizeny 
temi slechtenymi parametry

implementace a odzkoušení, publikace
… inspirovat se martinovou formulací
</pre>





<h4>Způsob řešení</h4>
<pre>
přesunuto sem:
---------------
- jedno takovy rozsireni do deduktivnosti je pridani predikatovejch symbolu v podobe typovejch trid. To 
  nam umozni efektivne popsat struktury od listu pevne delky, pres neuronove site pres monady atd linearni 
  gp atd. do řešení
- zde se bude navazovat na praci z diplomky, kde se podarilo formulovat generovani takovym zpusobem ze je 
  param (todle se spis hodi do zpusob reseni) atd...
- inhabitation tree, inhabitation machine, inhabitation paths. Roadmaps
- meZiproblemove interakce  - krizeni napric problemy , module acvision v globalni mape kombinatoru
- tohle spolecne s roadmapama pak tvori knowlidge base pro programovani "vyslovena" v jazyce logiky 
  odpovidajici tomu typovimu systemu 

--------------------------------------------------------
(nejtechnictejsi cast formulare)
(neni to jen výčet metod, ale mělo by to jít chronologicky)
(mělo by to adresovat cíle)

metody: odstavec o GP, krátkej, rychle jít na l. kalkuly
věci kolem prohledávání
typový systemy -- ty druhy
ACO

Chronologie - zkopírovat shora a utřídit dle cílů
-operatory: Vyzkouset krizeni s expanzi do ski vzdy pri skrizeni a nasledne to zase normalizovat - bojovat 
tim proti bloatu
-operatory: vyzkouset ACO na generovani jedincu a mutace - specialni aco se trema presnostma roadmap (
tree,machine,paths)
- meta: vyzkouset zdokonalit strategii z diplomky pomoci systemu samotneho
- posileni deduktivnosti: polymorfni typy
-  meta: rizeni sady ruznorodych ridicich parametru jako subpopulaci, krizeni subpopulaci skrizenim jejich 
ridicich parametru a slitim jejich populaci.
- posileni deduktivnosti:  skusit napasovat na typovej system logicky programovani v typovejch tridach, 
pomoci toho skusit nasimulovat klasickou GAs pres seznamy pevny dylky krs typ pro cisla, dal nervovy site 
krs nasobeni scitani prenos fun a sipky a permutace zavorek (rotace na stromech) a polymorfni kartezsky 
souciny
- bigcontext - vytvoreni sady problemu se stejnym kontexem v tuhle dobu uz bych mel mit z predchozich veci 
dostatek problemu na slucovani
-operatory: zrychlit generovani pomoci chytrejsi heuristiky v A* pro presny odhad vzdalenosti do 
nejblizsiho kompletniho termu z danyho unfin termu pres identifikaci unfin termu s tim samim "gama s 
pruhem"
</pre>


<pre>

  
Souč Stav Pozn : ZBYLé POZNAMKY
--------------------------------

- Kde zmínit citace na konkurenci a čim se od nich odlišujem?
  - konkurenci asi zmínit zde
  - odlišnosti ve způsobu řešení
- jetě si projít starý slajdy co sem dělal na štěpánka tam mám další propagandu (ale záměrně na to 
  kouknout až pak abych měl víc formulací a nebyl ovlivněnej tim starym)
- možná ještě kouknout na propagandu o typovanym v článkach - yu a kanadani a kombinatoři
- ADF vs trivialní fce explicitní aplikace
- LK : virtualní stroj popsatelný jedním řádkem (beta-redukce) 
</pre>


<hr>

<h3>Odvážnější výčet témat</h3>



<h4>JavaScriptová verze</h4>

<!-- - Propojení těch dvou barandrechtskejch odvozovacích pravidel do jedinýho -->

<h4>Polymorfizmus</h4>

<h4>Typový systém ala logické programování</h4>

<h4>Dependent types</h4>

<h4>ADF</h4>

<h4>"sem-tam-sem" Křížení</h4>

<!-- - ... nahradíme kombinátory ltermama a redukujem -->

<h4>Mutace</h4>

<h4>Generalized genetic operator</h4>



<h4>Multi-konstanty (aka čísla-like konstanty)</h4>



<h4>Mravenčí generování</h4>

<!--Roadmap a další Future ideas with Inhabitation trees-->



<h4>Paralelní běh několika problémů (nápad Petra Pudláka)</h4>

<h4>Module Acquisition</h4>



<h4>Paralelizace</h4>

<h4>Chytřejší heuristika pro A* která si to předpočítá na Gamma s čárkou</h4>

<h4>šlechtění prohledávacích strategií na generování termů</h4>



<h4>šlechtění fitness funkcí a nápad s "turnajem olympioniků"</h4>



<h4>Alternative family trees</h4>

<h4>Meta-evoluce: běhových parametrů ale i samotných algoritmů</h4>


<h4>Propojení s kutilem aka jednotné prostředí pro problémy</h4>


<h3>Problémy</h3>

<h4>Big Context problém</h4>

<h4>Šlechtění budov</h4>

<h4>Burza</h4>

<h4>Mouchy</h4>

<h4>Simulace ekonomie na urovni firem</h4>

<h4>Fish Fillets</h4>

<h4>Lego robot</h4>

<h4>NS</h4>

<h4>NP-ús</h4>


<!--

db       .d88b.  d8888b.     d8888b. db       .d8b.  d88888D d8b   db db    db 
88      .8P  Y8. 88  `8D     88  `8D 88      d8' `8b YP  d8' 888o  88 88    88 
88      88    88 88   88     88oooY' 88      88ooo88    d8'  88V8o 88 88    88 
88      88    88 88   88     88~~~b. 88      88~~~88   d8'   88 V8o88 88    88 
88booo. `8b  d8' 88  .8D     88   8D 88booo. 88   88  d8' db 88  V888 88b  d88 
Y88888P  `Y88P'  Y8888D'     Y8888P' Y88888P YP   YP d88888P VP   V8P ~Y8888P' 

-->


<section id="lod-blaznu">Loď bláznů</section>
<h3>Vincent a tekutý dědci</h3>
<i>(Anglicky: Vincent and the fluid geezers)</i>

<pre>
V hlave ma hlasu par
Je to zhouba? nebo dar?
V hlave ma hlasu par
Je to zhouba? nebo dar?

Z mesta byl vyhnan v dal
osudu napospas
Kdysi se tem zrudam smal
A ted s nima zdili kompas

V hlave ma hlasu par
Je to zhouba? nebo dar?
V hlave ma hlasu par
Je to zhouba? nebo dar?

Ve snu-se divny dedci mihaj
Jejich ksichty uz mu splivaj
Byl to vagus? nebo dabel?
a ten kus masa co se tam valel
v hube divna pachut kovu
Ted boji se usnout znovu
Dedci splivaj, je jich mnoho
Je jen jeden? A co z toho?

V hlave ma hlasu par
Neni to zhouba, je to dar
V hlave ma hlasu par
Neni to zhouba, je to dar
</pre>

<a href="sound/nastrel_theme_songu.mp3">poslechnout nástřel (lame)</a><br>
<a href="sound/prosekolashi3t.mp3">refrém s hudbičkou od gorge</a>

<todo>Projít si ty starý pokusy o příběh, patrně bych to měl mít někde
v google dokumentech: tyhle věci si ted vybavuju : </todo>

<ol>
<li> <b>organix machina</b> - ta je nějakej už celkem rafinovanej systém metafor 
bez konkrétního příběhu kerej jsem právě nechtěl uspěchat tak by se to mohlo pěkně doplnit,</li>
<li> <b>Mytologie Kutilství</b>, <b>hra</b>, - ta divadelní hra co sme plánovali s Aničkou,</li>
<li> <b>Oříšková singularita</b> pak tam mám nakej deleší slepenec takovej sešítek... -
je tam i dost zaznamů rozhovorů na fb (se ščem, pomem,..) atd co mi přišli zajímavý,</li>
<li> pak asi kouknout na <b>x-masakr mozek</b>,</li>
<li> <b>Myšlenkovník</b>,</li>
<li> a kouknout znova na obě <b>havle</b></li>
</ol>


<!--

.d8888. d888888b .88b  d88. db    db db       .d8b.  d888888b db    db d8888b. d88888b db   dD 
88'  YP   `88'   88'YbdP`88 88    88 88      d8' `8b `~~88~~' 88    88 88  `8D 88'     88 ,8P' 
`8bo.      88    88  88  88 88    88 88      88ooo88    88    88    88 88oobY' 88ooooo 88,8P   
  `Y8b.    88    88  88  88 88    88 88      88~~~88    88    88    88 88`8b   88~~~~~ 88`8b   
db   8D   .88.   88  88  88 88b  d88 88booo. 88   88    88    88b  d88 88 `88. 88.     88 `88. 
`8888Y' Y888888P YP  YP  YP ~Y8888P' Y88888P YP   YP    YP    ~Y8888P' 88   YD Y88888P YP   YD 

-->

<section id="simul">Simulátůrek</section>

Několik neuspořádaných nápadů:
<ul>
  <li>Základní prvky:
    <ul>
      <li>Svět - má zóny</li>
      <li>Zóna - má políčka</li>
      <li>Políčko - obsahuje objekty</li>
      <li>Objekty:
         <ul>
          <li>Strom</li>
          <li>Panáček/Robot - má vnitřek: inventář</li>
          <li>Barák - má vnitřek: něco jako vnitřní zóna </li>
         </ul>
      </li>
    </ul>
  </li> 

  <li>
    Mělo by to být designovaný s ohledem na princip <a href="#cocky">"čoček"</a>
  </li>

  <li>
    Měla by to být prostá hierarchie objektů ve stylu <a href="#json_">JSON_</a>,
    respektive to co to generuje jako výstup.
    <br> 
    Konkrétnějc: měl by bejt json_ serializovatelnej ten výstup simulátoru, tzn 
    stav/model světa. To prakticky asi znamená, že se by funkce (membři) toho 
    výstupního objektu měli bejt takový, že na nich toString() dá něco co de evalem
    rekonstruovat. To, jestli tam nejsou nějaký další šity znamená, že by tyhle funkce
    neměli bejt napojený na neviditelnej closure, tzn např že nevzniknou jako
    výstup nějaký jiný funkce, což je dost nepříjemný omezení. V <a href="#json_">JSON_</a>
    se to popisuje podrobněji, uvidí se jestli to bude mít nějaký praktický řešení.
    <br>
    To samozřejmě neomezuje použití kloužrů uvnitř toho simulátoru, jen že
    ve stavu světa by neměli bejt funkce, co maj clousre data.
  </li>

  <li>
    "problém cest" :
    když si budou moct zabrat uzemí kde budou chtít, tak můžou barákama
    obestavět jinej barák a ten nebude mít možnost dostat se k surovinám.
    Tzn vzniká tu agrese samovolně [železná ruka oligarchie jako fyzikální zákon]
    i když by se člověk snažil udělat to hezky "jehovisticky" - tzn explicitně
    jim tam nezavádět nějaký prvky agrese jako zbraně. 
  </li>

  <li>snažit se to udělat jako obecnej simulátor, kterej má jako argumenty
    "bussines rules" který udávaj konkretní arbitrární pravidla. Samozřejmě
    že tohle je někdy asi na úkor efektivity práce... nebo spíš lehkost
    práce, a mohlo by to tíhnout k premature rozhodnutím; takže to zklouzne k tomu, že
    budou nějaký věci co budou v jádru co by tam neměli bejt podle tohodle principu, 
    ale už od začátku to pojmout tak, že jsou tam rules do kerejch je možno refaktoringem
    transplantovat hardcoded věci z jádra simulátoru co by tam neměli bejt.
  </li>

  <li>
    Je otázka jak se postavit k indexování zón/políček, bylo by hezký, kdyby to bylo udělaný nějak obecně
    jak pro 2D i 3D. Nebo rovnou 3D? Nebo nejdřív 2D? 
    <br>
    Je lepší indexovat přímo stringovou adresou, nebo strukturovaně world[x][y][z]?
    Jeden string má nevýhodu v adjacentnostech atd - i když můžu použít strukturovaný
    objek zonePos a ten až přeložit na stringovou adresu.
  </li>
 
</ul>

<canvas id="sim_canvas" width="512" height="512"></canvas>
<script>$(function(){
  var ctx = $('#sim_canvas')[0].getContext('2d'); 
  var zona = mkZone();
  drawZone2D(ctx,zona);
});</script>

<h3>Trocha pokusného kódu</h3>

<script show="true">

var NUM_DIM   = 2;
var ZONE_SIDE = 32;


var mkWorld = function(){
  return {};
};

var defaultZoneInit2D = function(pos){
  var k =  256/ZONE_SIDE ;
  return {
    //pos:pos.join(),
    color : _.map(pos,function(x){return k*x;}).concat([75]) 
  };
};

var stepPole1 = function(pole,zone,pos){
  var ns = nejbrs(pos,true);
  ns = _.map(ns,function(n){return poleAt(zone,n)});
  hax = ns;
  return{ color: [ ns[0].color[2] , pole.color[2] , ns[2].color[2] ] };
};

var poleAt = function(zone,pos){
  if(pos.length===0){return zone;}
  return poleAt(zone[_.head(pos)],_.tail(pos));
};

var nejbrs = function(pos,isToroid,free){
  if(isToroid){
    if(free === undefined){free = true;}

    if(pos.length===0){return [[]];}


    var ret1 = [] ,ret2 = [], ret3 = [];

    var x = _.head(pos);

    if( free ){
      x1 = (x+1) % ZONE_SIDE;
      x2 = (x-1) % ZONE_SIDE;
      var ns = nejbrs( _.tail(pos) , isToroid ,false );
    
      ret1 = _.map(ns,function(n){return [x1].concat(n);});
      ret2 = _.map(ns,function(n){return [x2].concat(n);});
    }

    if( !(pos.length==1 && free) ){
      var ns_ = nejbrs( _.tail(pos) , isToroid ,free );
      ret3 = _.map(ns_,function(n){return [x].concat(n);});
      
    };

    return ret1.concat(ret2.concat(ret3));
  }

  throw 'TODO - nejbrs : to be implemented';
};

var stepZone = function(zone,stepPole){
  return z_map(zone,function(pole,pos){
    return stepPole(pole,zone,pos);
  });
};

var drawZone2D = function(ctx,zone){
  var side = 16;
  var i = 0;
  z_each(zone,function(pole,pos){
    var x = pos[0];
    var y = pos[1];
    
    ctx.fillStyle = 'rgb('+pole.color.join()+')';
    ctx.fillRect(x*side, y*side, (x+1)*side, (y+1)*side);
  
    i++;
  });
  //log(i);
};


var z_each = function(zone,fun,dim,pos){
  if(dim === undefined){ dim = NUM_DIM; }
  if(pos === undefined){ pos = []; }
  if(dim === 0){ return fun(zone,pos); }
  
  for( var i = 0 ; i < ZONE_SIDE ; i++ ){
    z_each(zone[i],fun,dim-1,pos.concat([i]));
  }
};

var z_map = function(zone,fun,dim,pos){
  if(dim === undefined){ dim = NUM_DIM; }
  if(pos === undefined){ pos = []; }
  if(dim === 0){ return fun(zone,pos); }
  
  var zone = []; 
  for( var i = 0 ; i < ZONE_SIDE ; i++ ){
    var subZone = z_map(zone[i],fun,dim-1,pos.concat([i]));
    zone.push(subZone);
  }
  return zone;
};

var mkZone = function(initFun,dim,pos){
  if(dim === undefined){ dim = NUM_DIM; }
  if(pos === undefined){ pos = []; }
  if(initFun === undefined){ initFun = defaultZoneInit2D;}
  if(dim === 0){ return initFun(pos); }
  
  var zone = []; 
  for( var i = 0 ; i < ZONE_SIDE ; i++ ){

    var subZone = mkZone(initFun,dim-1,pos.concat([i]));
    zone.push(subZone);

  }
  return zone;
};

// ZonePos -> String
var encodeZonePos = function( zonePos ){

  var arr2str = function(xs){
    return xs.splice(0,NUM_DIM).join();
  };

  if( _.isArray(zonePos) ){
    if(zonePos.length < NUM_DIM){
      var zonePos = _.clone(zonePos);
      while( zonePos.length < NUM_DIM){
        zonePos.push(0);
      }
    }
    return arr2str(zonePos);
  }

  if( _.isObject(zonePos) ){
    var x = zonePos.x || 0 ;
    var y = zonePos.y || 0 ;
    var z = zonePos.z || 0 ;
    return arr2str([x,y,z]);
  }

  throw 'encodeZonePos : unsupported zonePos format';  
};

// World -> ZonePos -> Zone
var getZone = function( world , zonePos ){
  return world[encodeZonePos(zonePos)];
};


$(function(){


});

</script>

<!--

 .o88b.  .d88b.   .o88b. db   dD db    db 
d8P  Y8 .8P  Y8. d8P  Y8 88 ,8P' `8b  d8' 
8P      88    88 8P      88,8P    `8bd8'  
8b      88    88 8b      88`8b      88    
Y8b  d8 `8b  d8' Y8b  d8 88 `88.    88    
 `Y88P'  `Y88P'   `Y88P' YP   YD    YP    

-->

<section id="cocky">Čočky</section>

Čočky jsou koncep založený na pozorování, že můžeme řetězit modely a views podobně
jako při skládání funkcí. Čočka nasazená na nějaký model generuje pohled na ten model, který může být zase
interpretován jako model další čočkou atd. Jedná se vlastně jen o funkci transformující objektu na jiný objekt,
nic složitého. Zdá se mi však, že by bylo chytré těmhle objektům dát jednotící "interfece" ve stylu 
<a href="#json_">JSONu_</a>. 

<!--

   d88b .d8888.  .d88b.  d8b   db         
   `8P' 88'  YP .8P  Y8. 888o  88         
    88  `8bo.   88    88 88V8o 88         
    88    `Y8b. 88    88 88 V8o88         
db. 88  db   8D `8b  d8' 88  V888         
Y8888P  `8888Y'  `Y88P'  VP   V8P C88888D 
                                          
-->

<section id="json_">JSON_</section>

Rozšíření JSONu o nějaký jednoduchý konstrukt zajišťující 
rozšíření o funkce. Něco ve stylu:

<pre>
{
  "name" : "Chuan",
  "age" : 10,
  "foo" : { "_" : "function (x){return x+1;}" }
}
</pre>

Který by se ale přeložil pomocí "JSON_.parse"
na objekt:

<pre>
{
  name : 'Chuan',
  age  : 10,
  foo  : function(x){return x+1;} 
}
</pre>

<p>
Podstatná vlastnost objektu který má být korektně převeden do JSONu_,
že by neměl nic schovávat do closure, aby jednoduché .toString() aplikované
na funkci nestratilo o funkci žádnou inforaci.
</p>

<p>
A samozřejmě closure neni jediná potíž, další potíž je, kde to vezme
context ve kterém bude interpretovat konstanty obecně (jména funkcí, konstant,..).
Přímočarý a pravděpodobně né moc dobrý je globální scope. Bude moct
referencovat svoje položky? Jaká bude politika vůči this?
</p>


<p>
Je otázka, zda se spokojit s esteticky pěkným ale nebezpečným "_". 
V zásadě však to myslím není problém použít, protože by němělo být vždy
jasné, že daný JSON  je vlastně JSON_. Případný atribut s klíčem "_" může být
zakódován jako "__" atd. nebo prostě bude zakázán. Zdá se mi to lepší, než
používat nějaké "__FUN__" apod. 
</p>

<p>
Zdá se, že se zákazem closure je docela netriviální potíž, protože to vylučuje
použít funkci vrácenou funkcí v objektu, který pak chceme serializovat. Např:
</p>

<pre>
foo = function(x){return function(y){return x(y);}}
bar = foo(Math.sin)
bar.toString() 

  ===> "function (y){return x(y);}"
  a né "function (y){return Math.sin(y);}"
</pre>

Věc co mě napadla a nevim do jaký míry je rylejtlá k tomuhle je to, že jde celkem
elegantně psát lambda termy přímo v jsonu:

<pre>
\x y.x y
{'x':{'y':['x','y']}}
případně
{'x y':['x','y']}
možná i dokonce (ale to už trochu strácí tu jednoduchou parzovatelnost)
{'x y':'x y'}

tzn něco jako 
{_:{'x':{'y':['x','y']}}}
místo
{_:"function(x){return function(y){return x(y);}}"}

ten seznam tam má hezkou vlastnost že
\ f g x. f x (g x)
jde jako
{f:{g:{x:[f,x,[g,x]]}}}
(případně)
{'f g x':[f,x,[g,x]]}
</pre>

Nevim jestli je to k něčemu dobrý, vypadá to ale že bude třeba ručně řešit
některý takový věci, pokud se nebudeme chtít ochudit o možnost funkcí co vracej funkce
a takováhle notace neni až taková pain-in-the-ass a je jednodušejc parsovatelná 
než plaintext.

<p><note>Možná přendat někam jinam až na to bude někde lepší místo</note></p>

<h3>Links</h3>
<a href="http://www.kristofdegrave.be/2012/07/json-serialize-and-deserialize.html">
blogpost : JSON: serialize and deserialize functions in JavaScript</a><br>
<a href="https://github.com/tarruda/super-json">
github repo : super-json</a>


<!-- 

d888888b db    db d8888b. db    db        db    db .d8888.        d8888b. db    db d8b   db  .d8b.  
`~~88~~' `8b  d8' 88  `8D `8b  d8'        88    88 88'  YP        88  `8D `8b  d8' 888o  88 d8' `8b 
   88     `8bd8'  88oodD'  `8bd8'         Y8    8P `8bo.          88   88  `8bd8'  88V8o 88 88ooo88 
   88       88    88~~~      88    C8888D `8b  d8'   `Y8b. C8888D 88   88    88    88 V8o88 88~~~88 
   88       88    88         88            `8bd8'  db   8D        88  .8D    88    88  V888 88   88 
   YP       YP    88         YP              YP    `8888Y'        Y8888D'    YP    VP   V8P YP   YP

-->

<section id="typy-vs-dyna">(Typovanost vs dynamičnost) vs (stroj vs člověk)</section>

Zde bych v budoucnu chtěl trochu rozebrat myšlenku, která mě občas napadá ohledně 
staticky typovaných vs dynamických jazyků. Respektive napadá mě od tý doby co si hraju s javascriptem,
potom co sem si poměrně dlouho hrál s haskellem. 
<br><br>

Hrubě ve zkratce: ačkoli oceňuju typovanost a jak člověku pomáhá, zároveň mám velkou 
zálibu v dynamických jazycích. Zatím si nepřijdu dost pevný v kramflecích abych vynášel moc silné soudy,
ale přijde mi že typy mohou člověka až nepříjemě svazovat, zvlážť když pracuje s metaprogramovacíma věcma.
Alespoň takový jsou moje zkušenosti po dělání Fištrona, může to bejt hodně daný mojí nezkušeností
haskellu nebo nějakejma špatnejma designovejma rozhodnutíma, ale přišlo mi že až nepřiměřeně
času jsem strávil fajtěnim typovýho systému v eval záležitostech. Naopak v JS je vše evalózní
jednoduché, jen halt má člověk tu velkou zodpovědnost nestřelit se do nohy, ktrerou typy z velké části
zjednodušují. Proto mě napadá (možná předčasně vzhledem k tomu že sem toho zas
tolik v js nenaprogramoval) že může být zajímave nahlížet na typy jako na <i>nástroj kterým 
koriguje lidský programátor strojového programátora, ale sám si může dovolit luxus nebýt jimy svázán</i>.
Spíš to tu poznamenávám, abych to měl někde poznamenáno, než že by to už byla moc hotová myšlenka.
Cejtim jí pocitově, do slov se jí ještě asi moc nechce.
<p>
Rozhodně se mi zdá, že dynamický jazyky jsou asi o něco vhodnější na dělání prototypů.
Kdy člověk ještě nemusí mít v hlavě moc představu o datovejch strukturách který je
vhjodný použít a ty se až "vyloupávaj" za běhu. Ve chvíli kdy se to vyloupne, tak může
mít smisl to ukotvit, přepsat v tyxpovanym jazyce - pokud vypadá že by to mohlo přinýst zlepšení
- zrychlení, zpřehlednění, zbezpečnění.. 
<p>
Na druhou stranu jsou zase věci co si člověk bez typů neužije, protože neni drženej tim zábradlíčkem
a nemůže si dovolit některý úlety. No je to na hlubší zamyšlení, ale aspoň něco.

<todo>ukázka todo :) .. rozepsat to tu víc .. </todo>


</body>
</html>



